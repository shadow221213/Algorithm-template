<!--
 * @Description: 
 * @Author: shadow221213
 * @Date: 2023-10-24 19:33:32
 * @LastEditTime: 2023-11-04 17:25:47
-->
# <div align="center">01背包</div>

<!-- TOC -->

- [01背包](#01背包)
  - [方法：](#方法)
    - [满足：](#满足)
    - [设：](#设)
      - [最多不超过 XX 容量：](#最多不超过-xx-容量)
      - [恰好为 XX （一般容量和价值相等）：](#恰好为-xx-一般容量和价值相等)
    - [基本思路：](#基本思路)
    - [空间优化：](#空间优化)
      - [滚动数组：](#滚动数组)
      - [一维空间优化：](#一维空间优化)
    - [注意：](#注意)
  - [例题：](#例题)

<!-- /TOC -->

## 方法：

### 满足：
每个物品只取一次

### 设：

#### 最多不超过 XX 容量：
``` C++
dp[i][j] 表示前 i 个物品，凑成容量最多不超过 j 的最大（或最小）价值，常见：
for( int i = 0; i <= sum; i++ )
    dp[0][i] = i >= nums[0] ? nums[0] : 0;
```

#### 恰好为 XX （一般容量和价值相等）：
``` C++
dp[i][j] 表示前 i 个物品，凑成容量为 j 为真，常见：dp[0][0] = true
```

### 基本思路：
``` C++
for 枚举物品
    for 枚举容量(由小到大) {
        int no; (不选)
        int yes; (选)

        dp[i][j] = max(no, yes); (或 min ，或 | )
    }
```

### 空间优化：

#### 滚动数组：
只依赖于两行数据，滚动计算即可

#### 一维空间优化：
将枚举容量那层反向（由大到小），即可省下一维空间

### 注意：
01背包的空间优化并不会降低时间复杂度，所以对于01背包问题，可直接写方便调试的朴素多维版本（在空间可接受的情况下），如果遇到卡空间，再进行优化

## 例题：
*416. 分割等和子集*

*1049. 最后一块石头的重量 II*